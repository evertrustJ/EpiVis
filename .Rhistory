for (i in lp_stan){
if (lp_stan[i]==-Inf||lp_stan[i]==Inf) lp_stan <- 0
}
any(lp_r - lp_stan>=max.tol) # check that they are within an error tolerance.
# log-posterior calculation in R
lp_r <- sapply(1:n_sim, function(ii) {
do.call(gsph_logpost, c(list(coord=coord), Pars[[ii]]))
})
## in this case these are equivalent, but will generate NaN for our test result
for (i in lp_r){
if (is.na(lp_r[i])) lp_r[i]<- 0
}
warnings()
lp_r
is.na(lp_r[1])
is.na(lp_r[11])
is.na(lp_r[12])
lp_r[12] = 0
lp_r
## in this case these are equivalent, but will generate NaN for our test result
for (i in 1:length(lp_r)){
if (is.na(lp_r[i])) lp_r[i] = 0
}
for (i in 1:length(lp_stan)){
if (lp_stan[i]==-Inf||lp_stan[i]==Inf) lp_stan[i] <- 0
}
any(lp_r - lp_stan>=max.tol) # check that they are within an error tolerance.
all(lp_r - lp_stan>=max.tol) # check that they are within an error tolerance.
!any(lp_r - lp_stan>=max.tol) # check that they are within an error tolerance.
any(lp_r - lp_stan<max.tol) # check that they are within an error tolerance.
all(lp_r - lp_stan<max.tol) # check that they are within an error tolerance.
#--- automated tests for qr_fit ------------------------------------------------
#' Author: Martin Lysy
require(rstan)
require(mniw)
#context("testing_functions")
source('R/testing_functions.R', echo=TRUE)
# simulate some data
n_obs <- 5
coord <- matrix(rnorm(n_obs*2), n_obs, 2)
range = rexp(1)
source('C:/Users/shanh/Downloads/EpiVis/R/testing_functions.R', echo=TRUE)
source('C:/Users/shanh/Downloads/EpiVis/R/testing_functions.R', echo=TRUE)
# simulate some data
n_obs <- 5
coord <- matrix(rnorm(n_obs*2), n_obs, 2)
range = rexp(1)
sill = rexp(1)
nugget = runif(1,min=0,max=sill)
mu = runif(1)
rate_all <- rmNorm(1, mu = rep(mu, n_obs),
Sigma = sph_cov(coord, range, sill, nugget))
# compile stan model
spat_mod <- stan_model("krig_test.stan")
# instantiate the model corresponding to p(mu, sigma, lambda | y, X) in Stan
spat_dat <- list(nobs = nrow(coord), npred = 0,coord = coord, rate_obs = rate_all)
spat_fit <- sampling(spat_mod, data = spat_dat, iter = 5000,
verbose = TRUE, chains = 1)
# simulate some parameter values
n_sim <- 15
set.seed(4242442) ## Sometimes a lot of NA's are generated
Pars <- replicate(n = n_sim, expr = {
list(range = rexp(1),
sill = rexp(1),
nugget = runif(1,min=0,max=sill),
mu = runif(1),
rate = rate_all,
rate_pred = numeric(0))
}, simplify = FALSE)
# log-posterior calculation in R
lp_r <- sapply(1:n_sim, function(ii) {
do.call(gsph_logpost, c(list(coord=coord), Pars[[ii]]))
})
# log-posterior calculation in Stan
lp_stan <- sapply(1:n_sim, function(ii) {
upars<-unconstrain_pars(object = spat_fit, pars = Pars[[ii]])
log_prob(object = spat_fit, upars=upars, adjust_transform = FALSE)
})
## in this case these are equivalent, but will generate NaN for our test result
for (i in 1:length(lp_r)){
if (is.na(lp_r[i])) lp_r[i] = 0
}
for (i in 1:length(lp_stan)){
if (lp_stan[i]==-Inf||lp_stan[i]==Inf) lp_stan[i] <- 0
}
all(lp_r - lp_stan<max.tol) # check that they are within an error tolerance.
set.seed(4242442) ## Sometimes a lot of NA's are generated; this interferes with our testing mechanism
# simulate some data
n_obs <- 5
coord <- matrix(rnorm(n_obs*2), n_obs, 2)
range = rexp(1)
sill = rexp(1)
nugget = runif(1,min=0,max=sill)
mu = runif(1)
rate_all <- rmNorm(1, mu = rep(mu, n_obs),
Sigma = sph_cov(coord, range, sill, nugget))
# compile stan model
spat_mod <- stan_model("krig_test.stan")
# instantiate the model corresponding to p(mu, sigma, lambda | y, X) in Stan
spat_dat <- list(nobs = nrow(coord), npred = 0,coord = coord, rate_obs = rate_all)
spat_fit <- sampling(spat_mod, data = spat_dat, iter = 5000,
verbose = TRUE, chains = 1)
# simulate some parameter values
n_sim <- 15
Pars <- replicate(n = n_sim, expr = {
list(range = rexp(1),
sill = rexp(1),
nugget = runif(1,min=0,max=sill),
mu = runif(1),
rate = rate_all,
rate_pred = numeric(0))
}, simplify = FALSE)
# log-posterior calculation in R
lp_r <- sapply(1:n_sim, function(ii) {
do.call(gsph_logpost, c(list(coord=coord), Pars[[ii]]))
})
# log-posterior calculation in Stan
lp_stan <- sapply(1:n_sim, function(ii) {
upars<-unconstrain_pars(object = spat_fit, pars = Pars[[ii]])
log_prob(object = spat_fit, upars=upars, adjust_transform = FALSE)
})
## in this case these are equivalent, but will generate NaN for our test result
for (i in 1:length(lp_r)){
if (is.na(lp_r[i])) lp_r[i] = 0
}
for (i in 1:length(lp_stan)){
if (lp_stan[i]==-Inf||lp_stan[i]==Inf) lp_stan[i] <- 0
}
all(lp_r - lp_stan<max.tol) # check that they are within an error tolerance.
set.seed(42422) ## Sometimes a lot of NA's are generated; this interferes with our testing mechanism
# simulate some data
n_obs <- 5
coord <- matrix(rnorm(n_obs*2), n_obs, 2)
range = rexp(1)
sill = rexp(1)
nugget = runif(1,min=0,max=sill)
mu = runif(1)
rate_all <- rmNorm(1, mu = rep(mu, n_obs),
Sigma = sph_cov(coord, range, sill, nugget))
# compile stan model
spat_mod <- stan_model("krig_test.stan")
# instantiate the model corresponding to p(mu, sigma, lambda | y, X) in Stan
spat_dat <- list(nobs = nrow(coord), npred = 0,coord = coord, rate_obs = rate_all)
spat_fit <- sampling(spat_mod, data = spat_dat, iter = 5000,
verbose = TRUE, chains = 1)
# simulate some parameter values
n_sim <- 15
Pars <- replicate(n = n_sim, expr = {
list(range = rexp(1),
sill = rexp(1),
nugget = runif(1,min=0,max=sill),
mu = runif(1),
rate = rate_all,
rate_pred = numeric(0))
}, simplify = FALSE)
# log-posterior calculation in R
lp_r <- sapply(1:n_sim, function(ii) {
do.call(gsph_logpost, c(list(coord=coord), Pars[[ii]]))
})
# log-posterior calculation in Stan
lp_stan <- sapply(1:n_sim, function(ii) {
upars<-unconstrain_pars(object = spat_fit, pars = Pars[[ii]])
log_prob(object = spat_fit, upars=upars, adjust_transform = FALSE)
})
## in this case these are equivalent, but will generate NaN for our test result
for (i in 1:length(lp_r)){
if (is.na(lp_r[i])) lp_r[i] = 0
}
for (i in 1:length(lp_stan)){
if (lp_stan[i]==-Inf||lp_stan[i]==Inf) lp_stan[i] <- 0
}
all(lp_r - lp_stan<max.tol) # check that they are within an error tolerance.
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
require(mniw)
require(mniw)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
#--- automated tests for qr_fit ------------------------------------------------
#' Author: Martin Lysy
require(rstan)
require(mniw)
#context("testing_functions")
source('testing_functions.R', echo=TRUE)
set.seed(42422) ## Sometimes a lot of NA's are generated; this interferes with our testing mechanism
setwd("C:/Users/shanh/Downloads/EpiVis/tests/testthat")
#--- automated tests for qr_fit ------------------------------------------------
#' Author: Martin Lysy
require(rstan)
require(mniw)
#context("testing_functions")
source('testing_functions.R', echo=TRUE)
set.seed(42422) ## Sometimes a lot of NA's are generated; this interferes with our testing mechanism
# simulate some data
n_obs <- 5
coord <- matrix(rnorm(n_obs*2), n_obs, 2)
range = rexp(1)
sill = rexp(1)
nugget = runif(1,min=0,max=sill)
mu = runif(1)
rate_all <- rmNorm(1, mu = rep(mu, n_obs),
Sigma = sph_cov(coord, range, sill, nugget))
# compile stan model
spat_mod <- stan_model("krig.stan")
# instantiate the model corresponding to p(mu, sigma, lambda | y, X) in Stan
spat_dat <- list(nobs = nrow(coord), npred = 0,coord = coord, rate_obs = rate_all)
spat_fit <- sampling(spat_mod, data = spat_dat, iter = 5000,
verbose = TRUE, chains = 1)
# simulate some parameter values
n_sim <- 15
Pars <- replicate(n = n_sim, expr = {
list(range = rexp(1),
sill = rexp(1),
nugget = runif(1,min=0,max=sill),
mu = runif(1),
rate = rate_all,
rate_pred = numeric(0))
}, simplify = FALSE)
# log-posterior calculation in R
lp_r <- sapply(1:n_sim, function(ii) {
do.call(gsph_logpost, c(list(coord=coord), Pars[[ii]]))
})
# log-posterior calculation in Stan
lp_stan <- sapply(1:n_sim, function(ii) {
upars<-unconstrain_pars(object = spat_fit, pars = Pars[[ii]])
log_prob(object = spat_fit, upars=upars, adjust_transform = FALSE)
})
## in this case these are equivalent, but will generate NaN for our test result
for (i in 1:length(lp_r)){
if (is.na(lp_r[i])) lp_r[i] = 0
}
for (i in 1:length(lp_stan)){
if (lp_stan[i]==-Inf||lp_stan[i]==Inf) lp_stan[i] <- 0
}
all(lp_r - lp_stan<max.tol) # check that they are within an error tolerance.
devtools::check()
devtools::check()
source('C:/Users/shanh/Downloads/EpiVis/tests/testthat/testing_functions.R', echo=TRUE)
source('C:/Users/shanh/Downloads/EpiVis/tests/testthat/testing_functions.R', echo=TRUE)
source('C:/Users/shanh/Downloads/EpiVis/tests/testthat/testing_functions.R', echo=TRUE)
#--- automated tests for qr_fit ------------------------------------------------
#' Author: Martin Lysy
require(rstan)
require(mniw)
#context("testing_functions")
source('testing_functions.R', echo=TRUE)
set.seed(42422) ## Sometimes a lot of NA's are generated; this interferes with our testing mechanism
# simulate some data
n_obs <- 5
coord <- matrix(rnorm(n_obs*2), n_obs, 2)
range = rexp(1)
sill = rexp(1)
nugget = runif(1,min=0,max=sill)
mu = runif(1)
rate_all <- rmNorm(1, mu = rep(mu, n_obs),
Sigma = sph_cov(coord, range, sill, nugget))
# compile stan model
spat_mod <- stan_model("krig.stan")
spat_fit <- sampling(spat_mod, data = spat_dat, iter = 500,
verbose = TRUE, chains = 1)
# instantiate the model corresponding to p(mu, sigma, lambda | y, X) in Stan
spat_dat <- list(nobs = nrow(coord), npred = 0,coord = coord, rate_obs = rate_all)
spat_fit <- sampling(spat_mod, data = spat_dat, iter = 500,
verbose = TRUE, chains = 1)
# simulate some parameter values
n_sim <- 15
print(rate_all)
Pars <- replicate(n = n_sim, expr = {
list(range = rexp(1),
sill = rexp(1),
nugget = runif(1,min=0,max=sill),
mu = runif(1),
rate_obs = rate_all,
rate_pred = numeric(0))
}, simplify = FALSE)
# log-posterior calculation in R
lp_r <- sapply(1:n_sim, function(ii) {
do.call(gsph_logpost, c(list(coord=coord), Pars[[ii]]))
})
# log-posterior calculation in Stan
lp_stan <- sapply(1:n_sim, function(ii) {
upars<-unconstrain_pars(object = spat_fit, pars = Pars[[ii]])
log_prob(object = spat_fit, upars=upars, adjust_transform = FALSE)
})
## in this case these are equivalent, but will generate NaN for our test result
for (i in 1:length(lp_r)){
if (is.na(lp_r[i])) lp_r[i] = 0
}
for (i in 1:length(lp_stan)){
if (lp_stan[i]==-Inf||lp_stan[i]==Inf) lp_stan[i] <- 0
}
all(lp_r - lp_stan<max.tol) # check that they are within an error tolerance.
lp_stan
lp_r
#context("testing_functions")
source('testing_functions.R', echo=TRUE)
set.seed(42422) ## Sometimes a lot of NA's are generated; this interferes with our testing mechanism
# simulate some data
n_obs <- 5
coord <- matrix(rnorm(n_obs*2), n_obs, 2)
range = rexp(1)
sill = rexp(1)
nugget = runif(1,min=0,max=sill)
mu = runif(1)
rate_all <- rmNorm(1, mu = rep(mu, n_obs),
Sigma = sph_cov(coord, range, sill, nugget))
# compile stan model
spat_mod <- stan_model("krig.stan")
# instantiate the model corresponding to p(mu, sigma, lambda | y, X) in Stan
spat_dat <- list(nobs = nrow(coord), npred = 0,coord = coord, rate_obs = rate_all)
spat_fit <- sampling(spat_mod, data = spat_dat, iter = 500,
verbose = TRUE, chains = 1)
# simulate some parameter values
n_sim <- 15
print(rate_all)
Pars <- replicate(n = n_sim, expr = {
list(range = rexp(1),
sill = rexp(1),
nugget = runif(1,min=0,max=sill),
mu = runif(1),
rate_obs = rate_all,
rate_pred = numeric(0))
}, simplify = FALSE)
# log-posterior calculation in R
lp_r <- sapply(1:n_sim, function(ii) {
do.call(gsph_logpost, c(list(coord=coord), Pars[[ii]]))
})
# log-posterior calculation in Stan
lp_stan <- sapply(1:n_sim, function(ii) {
upars<-unconstrain_pars(object = spat_fit, pars = Pars[[ii]])
log_prob(object = spat_fit, upars=upars, adjust_transform = FALSE)
})
## in this case these are equivalent, but will generate NaN for our test result
for (i in 1:length(lp_r)){
if (is.na(lp_r[i])) lp_r[i] = 0
}
for (i in 1:length(lp_stan)){
if (lp_stan[i]==-Inf||lp_stan[i]==Inf) lp_stan[i] <- 0
}
all(lp_r - lp_stan<max.tol) # check that they are within an error tolerance.
devtools::check()
remove.packages("EpiVis")
devtools::build()
devtools::install()
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
china_grid <- epi_grid(china_covid, 170) # Want 170 points in the rectangle
#  but only part of them would be in
#  the map of china.
plot(china_grid, xlab="Longitude", ylab="Latitude", pch=15)
require(rstan)
options(mc.cores = parallel::detectCores())
#Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
rstan_options(auto_write = TRUE)
fit <- epi_bayesian_krig(china_covid, china_grid, mod='krig', chain=4, iter=400)
## This saves a "spatial_stan.Rda" file locally automatically,
##   as it is a side effect by epi_bayesian_krig.
r <- extract(fit, pars="rate_pred")
rate_pred <- NULL
library(maps)
for (i in 1:ncol(r$rate_pred)){
rate_pred[i] = mean(r$rate_pred[401:800,i])
}
grid_pred <- cbind(china_grid$x, china_grid$y, rate_pred)
grid_pred <- grid_pred[order(rate_pred),]
## Some color of choice
col=c(rep(heat.colors(4)[4], nrow(grid_pred)/4),
rep(heat.colors(4)[3], nrow(grid_pred)/4),
rep(heat.colors(4)[2], nrow(grid_pred)/4),
rep(heat.colors(4)[1], nrow(grid_pred)/4))
china_covid <- china_covid[order(china_covid$rate),]
col2=c(rep(heat.colors(4)[4],8), rep(heat.colors(4)[3],8),
rep(heat.colors(4)[2],8), rep(heat.colors(4)[1], 8))
map('world','china')
points(grid_pred[,1], grid_pred[,2], col=col, pch=15, cex=1.5)
title(main=expression('Rate of Disease per 10000 people'),  xlab="Longitude", ylab="Latitude")
map('world','china')
points(china_covid$x, china_covid$y, col=col2, pch=15, cex=1.5)
title(main=expression('Mock Data Collected'),  xlab="Longitude", ylab="Latitude")
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
epi_heatmap(epi=china_covid, pts=170)
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
china_estimate <- epi_interpolate(china_covid, 150)
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
china_estimate <- epi_interpolate(china_covid, 50)
china_estimate
#epi_heatmap(epi=china_covid, pts=170)
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
grid <- epi_grid(china_covid, pts)
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
grid <- epi_grid(china_covid, 100)
#china_estimate <- epi_interpolate(china_covid, 50)
#china_estimate
#epi_heatmap(epi=china_covid, pts=170)
devtools::check()
devtools::build()
devtools::install()
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
grid <- epi_grid(china_covid, 100)
#china_estimate <- epi_interpolate(china_covid, 50)
#china_estimate
#epi_heatmap(epi=china_covid, pts=170)
View(grid)
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
grid <- epi_grid(china_covid, 100)
china_estimate <- epi_interpolate(china_covid, 50)
#china_estimate
#epi_heatmap(epi=china_covid, pts=170)
View(china_estimate)
View(china_estimate)
View(grid_pred)
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
grid <- epi_grid(china_covid, 100)
china_estimate <- epi_interpolate(china_covid, 100)
#china_estimate
#epi_heatmap(epi=china_covid, pts=170)
View(china_estimate)
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
china_grid <- epi_grid(china_covid, 170) # Want 170 points in the rectangle
#  but only part of them would be in
#  the map of china.
plot(china_grid, xlab="Longitude", ylab="Latitude", pch=15)
View(r)
devtools::build()
devtools::install()
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
grid <- epi_grid(china_covid, 100)
china_estimate <- epi_interpolate(china_covid, 100)
#china_estimate
#epi_heatmap(epi=china_covid, pts=170)
View(china_estimate)
library(EpiVis)
covid19_china_province <- read.csv("provinces_test.csv")
china_covid <- epi_converge(x=covid19_china_province$longitudes,
y=covid19_china_province$latitudes,
case=covid19_china_province$total_con,
population=covid19_china_province$populations,
map='china')
grid <- epi_grid(china_covid, 100)
epi_heatmap(epi=china_covid, pts=170)
devtools::check()
